---
title: "Multinomial Regression with Clustering Using the Bootstrap"
author: "Jennifer Thompson"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This example will use the `gapminder` data to demonstrate a multinomial logistic regression model using cluster bootstrapping to calculate estimates and variances and showing the resulting odds ratios and predicted probabilities.

List of vignettes I'd like to include later:

- how to get estimates for *all* levels of the outcome vs all others (vs sticking with one reference level)
- using ClusterMultinom with multiple imputation

## Data and Simple Model Fit

A multinomial outcome has >2 unordered categories. This fits the criteria of Earth's continents, which are included in the [`gapminder`](https://cran.r-project.org/package=gapminder) data, along with characteristics of each country in a given year.

```{r}
library(gapminder)
head(gapminder)
```

Let's say we want to look at the relationship between each continent and life expectancy, population and GDP. One option is to use `vglm()` from the [`VGAM`](https://cran.r-project.org/web/packages/VGAM/index.html) package, with `family = multinomial()`, to model the log odds of a data point being from a certain continent.[^1]

We'll use `Africa` as our reference category, and since `Oceania` has relatively few records, for purposes of model stability we'll combine it with `Asia`. (This may or may not be the best approach, but we'll leave that to sociologists.)

```{r fit_model_nocluster}
library(VGAM, quietly = TRUE)

## Combine Australia/NZ with Asia to help model stability
gapminder$continent <- with(gapminder, {
  ifelse(continent == "Oceania", "Asia", as.character(continent))
})

## Fit model with outcome = continent,
##  exposures = life expectancy, population, GDP
our_mod <- vglm(
  continent ~ lifeExp + pop + gdpPercap,
  data = gapminder,
  family = multinomial(refLevel = "Africa")
)

## Print model summary
summary(our_mod)

```

We get three sets of coefficients; each one describes the log odds of a data point being from Europe, Asia or the Americas vs Africa.


## Accounting for Clustering

But let's say we want to account for the fact that our data are clustered by year; for example, correlations between records from the same continent may vary over time, or correlations among the continents may vary over time.

Here, we'll use the **bootstrap** to account for this clustering. A basic outline of the process:

- Sample our clusters with replacement
- Create a dataset with all records from each of our sampled clusters
- Fit our multinomial model on this dataset and save the coefficients
- Repeat this process B times

We'll use the coefficients from all B models to get our point estimates and variance-covariance estimates that we'll use in estimating our model results.

## Step 1: Create Our Datasets

`ClusterMultinom::create_bootdata()` takes as arguments:

1. An original dataset (multiple rows per cluster; `data.frame`)
1. A single clustering variable name (column name in original dataset; `character`)
1. A positive integer representing the number of bootstraps requested
1. A seed (optional, to ensure reproducibility; `numeric`)

It returns a **list** of length `nboot`, where each element is a cluster bootstrapped dataset.

```{r create_gapminder_bootdata}
library(ClusterMultinom)

gap_bootdfs <- create_bootdata(
  df = gapminder,
  cluster_var = "year",
  nboot = 10,
  seed = 1234
)

length(gap_bootdfs)
```

## Step 2: Run the Model on Each Dataset

`ClusterMultinom::run_multinom_boot()` takes as required arguments:

1. A model formula
1. Which level of the outcome to use as a reference
1. A list of datasets, all with the same column names *(eg, one created by `ClusterMultinom::create_bootdata()`)*

It also takes as optional arguments:

1. The original dataset, of the same format as each element of your list of bootstrapped datasets.

    *If not specified, the function uses the first element of the list.*
    
1. The number of successful model fits required.

    Depending on the distribution of the outcome and the complexity of the model, some bootstrap datasets may not produce a model fit that converges. We recommend creating some "extra" datasets in Step 1, and having `run_multinom_boot()` run until you have achieved B successful model fits. (One of the reasons we chose `VGAM::vglm()` to use first was its conservative warnings.)

    *If not specified, the function uses 85% of the length of the list of datasets.*

```{r run_gapminder_models}


# continent ~ lifeExp + pop + gdpPercap


```






Great, now we have correct variance-covariance between all our coefficients! Now we can get the correct results.

Everybody loves a p-value.

    << this is where we have a function that gets p-values for a single/group of covariates >>
    
But p-values are imperfect and don't tell us anything about directionality or magnitude of effect.

Let's look at odds ratios!

    << this is where we have a function that gets odds ratios + CIs for a single covariate given a design matrix >>
    << and we plot them >>

But for continuous covariates like life expectancy, sometimes we want to plot the association over an entire range of the covariate, especially if we used something like restricted cubic splines, where the slope in our association isn't constant.

    << this is where we have a function that gets predicted probabilities + CIs for a single covariate given a design matrix >>
    << and we plot them >>

[^1]: There are other options for multinomial regression in R, including `nnet::multinom()` and the `mlogit` package. We chose `VGAM::vglm()` because its warning messages were the most conservative and verbose, which is particularly helpful in the context of bootstrapping.